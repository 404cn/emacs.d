*** Helm

#+begin_src elisp :exports none
  ;;----------------------------------------------------------------------------
  ;; Grep
#+end_src

**** Helm

#+begin_src elisp
  (use-package helm
     :defer t
     :straight t
     :diminish helm-mode
     :bind (("M-x"       . helm-M-x)
            ("C-o"       . helm-occur)
            ("<f1> SPC"  . helm-all-mark-rings) ; I modified the keybinding
            ("M-y"       . helm-show-kill-ring)
            ("C-x c x"   . helm-register)    ; C-x r SPC and C-x r j
            ("C-x c g"   . helm-google-suggest)
            ("C-x c M-:" . helm-eval-expression-with-eldoc)
            ("C-x C-f"   . helm-find-files)
            ("C-x b"     . nasy:helm)      ; *<major-mode> or /<dir> or !/<dir-not-desired> or @<regexp>
            :map helm-map
            ("<tab>" . helm-execute-persistent-action) ; rebind tab to run persistent action
            ("C-i"   . helm-execute-persistent-action) ; make TAB works in terminal
            ("C-z"   . helm-select-action) ; list actions using C-z
            :map shell-mode-map
            ("C-c C-l" . helm-comint-input-ring) ; in shell mode
            :map minibuffer-local-map
            ("C-c C-l" . helm-minibuffer-history))
     :hook ((after-init . (lambda () (helm-mode 1)))
            (after-init . (lambda () (helm-autoresize-mode 1))))
     :init
     (require 'helm-config)

     (setq helm-M-x-fuzzy-match        t
           helm-buffers-fuzzy-matching t
           helm-recentf-fuzzy-match    t
           helm-imenu-fuzzy-match      t
           helm-locate-fuzzy-match     t
           helm-apropos-fuzzy-match    t
           helm-lisp-fuzzy-completion  t)

     (when (executable-find "curl")
       (setq helm-google-suggest-use-curl-p t))

     (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
           helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
           helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
           helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
           helm-ff-file-name-history-use-recentf t
           helm-echo-input-in-header-line        t)

     :config
     (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)

     (require 'helm-buffers)
     (require 'helm-for-files)

     (defun nasy:helm ()
       (interactive)
       (let ((helm-ff-transformer-show-only-basename nil)
             helm-source-list)
         (unless helm-source-buffers-list
           (setq helm-source-buffers-list
                 (helm-make-source "Buffers" 'helm-source-buffers)))
         (cond (
                ;; Just add helm-source-projectile-* in list when current place in project.
                (projectile-project-p)
                (setq helm-source-list
                      '(
                        ;; helm-source-awesome-tab-group
                        helm-source-projectile-buffers-list
                        helm-source-buffers-list
                        helm-source-recentf
                        helm-source-projectile-files-list
                        )))
               (t
                (setq helm-source-list
                      '(
                        ;; helm-source-awesome-tab-group
                        helm-source-buffers-list
                        helm-source-recentf
                        ))
                ))
         (helm-other-buffer helm-source-list "*helm search*"))))
#+end_src

**** Helm Posframe

#+begin_src elisp
  (use-package helm-posframe
    :straight t
    :config
    (gsetq helm-posframe-poshandler #'posframe-poshandler-frame-top-center)
    (helm-posframe-enable))
#+end_src

**** Helm Org

#+begin_src elisp
  (use-package helm-org
    :defer t
    :config
    (cl-defun helm-org-headings-in-buffer ()
      (interactive)
      (helm :sources (helm-source-org-headings-for-files
                      (list (projectile-completing-read
                             "File to look at headings from: "
                             (projectile-all-project-files))))
            :candidate-number-limit 99999
            :buffer "*helm org inbuffer*")))
#+end_src

**** Helm Company

#+begin_src elisp
  (use-package helm-company
    :after    company
    :demand   t
    :straight t
    :bind (:map
           company-mode-map ("C-:" . helm-company)
           :map
           company-active-map ("C-:" . helm-company)))
#+end_src

**** Helm Shell

#+begin_src elisp
  (use-package helm-eshell
    :after helm
    :bind (:map eshell-mode-map
                ("C-c C-l" . helm-eshell-history)))
#+end_src

**** Helm Descbings

#+begin_src elisp
  (use-package helm-descbinds
    :straight t
    :after helm
    :hook ((after-init . helm-descbinds-mode)))
#+end_src

**** Helm Projectile

#+begin_src elisp
  (use-package helm-projectile
    :straight t
    :hook ((after-init . helm-projectile-on))
    :init
    (setq projectile-completion-system 'helm))
#+end_src

**** Helm Ag

#+begin_src elisp
  (use-package helm-ag
    :straight t
    :init (setq helm-ag-fuzzy-match t
                helm-ag-use-grep-ignore-list t
                helm-ag-use-agignore t))
#+end_src

**** Helm Dash

#+begin_src elisp
  (use-package helm-dash
    :straight t
    :init (setq helm-dash-docsets-path "~/.docsets"))
#+end_src

**** Helm Swoop

#+begin_src elisp
  (use-package helm-swoop
    :straight t
    ;; :bind (("C-s" . helm-swoop))
    :init (setq helm-swoop-move-to-line-cycle   t
                helm-swoop-use-line-number-face t
                helm-swoop-use-fuzzy-match      t))
#+end_src

**** Helm Ls Git

#+begin_src elisp
  (use-package helm-ls-git
    :straight t
    :bind (("C-<f6>"   . helm-ls-git-ls)
           ("C-x g"    . helm-ls-git-ls)
           ("C-x C-d"  . helm-browse-project)))
#+end_src
